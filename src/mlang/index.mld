{0 Mlang}

The Mlang compiler has a traditionnal architecture consisting of various
intermediate representations going from the source code to the target backend.

{1 Frontend}

First, the source code is parsed according to the Menhir grammar specified in {!module: Mlang.M_frontend.Mparser}.
The grammar is not exactly LR(1) so we rely on {!module: Mlang.M_frontend.Parse_utils} to backtrack, especially on symbol parsing. The target intermediate representation is {!module: Mlang.M_frontend.Mast}, which is very close to the concrete syntax and can be printed using {!module: Mlang.M_frontend.Format_mast}.
The frontend also handles ast expansion with {!module: Mlang.M_frontend.Expander} and validation with {!module: Mlang.M_frontend.Validator}.

{!modules:
  Mlang.M_frontend.Expander
  Mlang.M_frontend.Mast
  Mlang.M_frontend.Mlexer
  Mlang.M_frontend.Mparser
  Mlang.M_frontend.Parse_utils
  Mlang.M_frontend.Validator }

{1 Intermediate Representation}

The M language has a lot of weird syntactic sugars and constructs linked to its
usage inside multiple DGFiP applications. {!module: Mlang.M_frontend.Mast_to_mir} extracts from the AST of {!module: Mlang.M_frontend.Mast} the computational core corresponding to a DGFiP application into the M Variable Graph ({!module: Mlang.M_ir.Mir}), which consists basically of a flat map of all the definitions of
the variables used in the application. The type system of M is very primitive,
and basically all programs typecheck ; however {!module: Mlang.M_frontend.Validator} provides a top-down typechecking algorithm to split simple variables from tables.

{!modules:
  Mlang.M_ir.Com
  Mlang.M_ir.Format_mir
  Mlang.M_ir.Mir
  Mlang.M_ir.Mir_interpreter
  Mlang.M_ir.Mir_number
  Mlang.M_ir.Mir_roundops }

{1 Testing}

Mlang comes with a testing framework for M programs that is based on
the test format used by the DGFiP. The test files are parsed with
{!module: Mlang.Irj_utils.Irj_file}. Then, single
or batch testing can be performed using {!module: Mlang.Irj_utils.Test_interpreter}.

{!modules:
  Mlang.Irj_utils.Irj_ast
  Mlang.Irj_utils.Irj_file
  Mlang.Irj_utils.Irj_lexer
  Mlang.Irj_utils.Irj_parser
  Mlang.Irj_utils.ParserMessages
  Mlang.Irj_utils.Test_interpreter }

{1 Compiling}

M/M++ programs can be compiled to other programming languages using
several backends that take BIR and produce source code files in their
respective languages.

{!modules:
  Mlang.Backend_compilers.Bir_to_dgfip_c
  Mlang.Backend_compilers.DecoupledExpr
  Mlang.Backend_compilers.Dgfip_compir_files
  Mlang.Backend_compilers.Dgfip_gen_files
  Mlang.Backend_compilers.Dgfip_varid
  Mlang.Backend_compilers.Prelude
  }

{1 Utils }

{!modules:
  Mlang.Utils.CharMap
  Mlang.Utils.Cli
  Mlang.Utils.Config
  Mlang.Utils.Dgfip_m
  Mlang.Utils.Dgfip_options
  Mlang.Utils.Dict
  Mlang.Utils.Errors
  Mlang.Utils.IntMap
  Mlang.Utils.IntSet
  Mlang.Utils.IntSetMap
  Mlang.Utils.MapExt
  Mlang.Utils.Pos
  Mlang.Utils.Pp
  Mlang.Utils.SetExt
  Mlang.Utils.SetSetExt
  Mlang.Utils.Sorting
  Mlang.Utils.StrMap
  Mlang.Utils.StrSet
  Mlang.Utils.StrSetMap
  Mlang.Utils.StrSetSet
  Mlang.Utils.Strings
  Mlang.Utils.TopologicalSorting
 }
