<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>DecoupledExpr (mlang.Mlang.DecoupledExpr)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">mlang</a> &#x00BB; <a href="../index.html">Mlang</a> &#x00BB; DecoupledExpr</nav><header class="odoc-preamble"><h1>Module <code><span>Mlang.DecoupledExpr</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#low-level-m-computation">Low-level M computation</a><ul><li><a href="#local-variables">Local variables</a></li><li><a href="#constr">Expression constructors</a></li><li><a href="#decoupled-expressions">Decoupled expressions</a></li></ul></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-offset" class="anchored"><a href="#type-offset" class="anchor"></a><code><span><span class="keyword">type</span> offset</span><span> = </span></code><table><tr id="type-offset.GetValueConst" class="anchored"><td class="def variant constructor"><a href="#type-offset.GetValueConst" class="anchor"></a><code><span>| </span><span><span class="constructor">GetValueConst</span> <span class="keyword">of</span> int</span></code></td></tr><tr id="type-offset.GetValueExpr" class="anchored"><td class="def variant constructor"><a href="#type-offset.GetValueExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">GetValueExpr</span> <span class="keyword">of</span> string</span></code></td></tr><tr id="type-offset.GetValueVar" class="anchored"><td class="def variant constructor"><a href="#type-offset.GetValueVar" class="anchor"></a><code><span>| </span><span><span class="constructor">GetValueVar</span> <span class="keyword">of</span> <a href="../Com/Var/index.html#type-t">Com.Var.t</a></span></code></td></tr><tr id="type-offset.PassPointer" class="anchored"><td class="def variant constructor"><a href="#type-offset.PassPointer" class="anchor"></a><code><span>| </span><span><span class="constructor">PassPointer</span></span></code></td></tr><tr id="type-offset.None" class="anchored"><td class="def variant constructor"><a href="#type-offset.None" class="anchor"></a><code><span>| </span><span><span class="constructor">None</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-generate_variable" class="anchored"><a href="#val-generate_variable" class="anchor"></a><code><span><span class="keyword">val</span> generate_variable : 
  <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?def_flag:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?trace_flag:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Com/Var/index.html#type-t">Com.Var.t</a> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-dflag" class="anchored"><a href="#type-dflag" class="anchor"></a><code><span><span class="keyword">type</span> dflag</span><span> = </span></code><table><tr id="type-dflag.Def" class="anchored"><td class="def variant constructor"><a href="#type-dflag.Def" class="anchor"></a><code><span>| </span><span><span class="constructor">Def</span></span></code></td></tr><tr id="type-dflag.Val" class="anchored"><td class="def variant constructor"><a href="#type-dflag.Val" class="anchor"></a><code><span>| </span><span><span class="constructor">Val</span></span></code></td></tr></table></div></div><h2 id="low-level-m-computation"><a href="#low-level-m-computation" class="anchor"></a>Low-level M computation</h2><p>This module distinguish defineness and valuation computations of M expressions so they can be expressed independantly and more thoroughtly optimized. Definition of such expression follows as such:</p><ul><li>Express the computation of definess and valuation independantly through the use of constructors in <a href="#constr">Expression constructors</a></li><li>Sub-expressions can be used to build up the M expression tree (see <a href="#type-expression_composition"><code>expression_composition</code></a>)</li><li>A fully defined expression can be processed into a optimized value that can be printed (<a href="#val-build_expression"><code>build_expression</code></a>)</li></ul><h3 id="local-variables"><a href="#local-variables" class="anchor"></a>Local variables</h3><div class="odoc-spec"><div class="spec type" id="type-local_var" class="anchored"><a href="#type-local_var" class="anchor"></a><code><span><span class="keyword">type</span> local_var</span></code></div><div class="spec-doc"><p>Variable local to the computed expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-locals_from_m" class="anchored"><a href="#val-locals_from_m" class="anchor"></a><code><span><span class="keyword">val</span> locals_from_m : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-local_var">local_var</a> * <a href="#type-local_var">local_var</a></span></code></div><div class="spec-doc"><p>Return a couple of local variable from a MIR one, for defineness and valuation in this order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-new_local" class="anchored"><a href="#val-new_local" class="anchor"></a><code><span><span class="keyword">val</span> new_local : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-local_var">local_var</a></span></code></div><div class="spec-doc"><p>Create a fresh local variable</p></div></div><h3 id="constr"><a href="#constr" class="anchor"></a>Expression constructors</h3><p>These are the smart constructors used to build expressions. In effect, they represent the language in which computations are defined.</p><p>They are used as traditional nestable sum-type constructors. An example:</p><pre>0.5 * (x + y)</pre><p>would turn into</p><pre><code>mult (lit 0.5) (plus (local_var x) (local_var y)) </code></pre><p>where <code>x</code> and <code>y</code> are previously defined <a href="#val-local_var"><code>local_var</code></a>s</p><div class="odoc-spec"><div class="spec type" id="type-constr" class="anchored"><a href="#type-constr" class="anchor"></a><code><span><span class="keyword">type</span> constr</span></code></div><div class="spec-doc"><p>Constructed decoupled expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dtrue" class="anchored"><a href="#val-dtrue" class="anchor"></a><code><span><span class="keyword">val</span> dtrue : <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>True value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dfalse" class="anchored"><a href="#val-dfalse" class="anchor"></a><code><span><span class="keyword">val</span> dfalse : <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>False value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lit" class="anchored"><a href="#val-lit" class="anchor"></a><code><span><span class="keyword">val</span> lit : <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Float literal</p></div></div><div class="odoc-spec"><div class="spec value" id="val-m_var" class="anchored"><a href="#val-m_var" class="anchor"></a><code><span><span class="keyword">val</span> m_var : <span><a href="../Com/Var/index.html#type-t">Com.Var.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-dflag">dflag</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Value from TGV. <code>m_var v off df</code> represents an access to the TGV variable <code>v</code> with <code>df</code> to read defineness or valuation. <code>off</code> is the access type for M array, and should be <code>None</code> most of the time. For array access, see <a href="#val-access"><code>access</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-let_local" class="anchored"><a href="#val-let_local" class="anchor"></a><code><span><span class="keyword">val</span> let_local : <span><a href="#type-local_var">local_var</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Local let-binding. <code>let_local v defining_expr body_expr</code> is akin to OCaml <code>let v = defining_expr in body_expr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-local_var" class="anchored"><a href="#val-local_var" class="anchor"></a><code><span><span class="keyword">val</span> local_var : <span><a href="#type-local_var">local_var</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Access local variable value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dand" class="anchored"><a href="#val-dand" class="anchor"></a><code><span><span class="keyword">val</span> dand : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Boolean and</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dor" class="anchored"><a href="#val-dor" class="anchor"></a><code><span><span class="keyword">val</span> dor : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Boolean or</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dnot" class="anchored"><a href="#val-dnot" class="anchor"></a><code><span><span class="keyword">val</span> dnot : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Boolean not</p></div></div><div class="odoc-spec"><div class="spec value" id="val-minus" class="anchored"><a href="#val-minus" class="anchor"></a><code><span><span class="keyword">val</span> minus : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Negate value</p></div></div><div class="odoc-spec"><div class="spec value" id="val-plus" class="anchored"><a href="#val-plus" class="anchor"></a><code><span><span class="keyword">val</span> plus : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Float addition</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Float substraction</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mult" class="anchored"><a href="#val-mult" class="anchor"></a><code><span><span class="keyword">val</span> mult : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Float multiplication</p></div></div><div class="odoc-spec"><div class="spec value" id="val-div" class="anchored"><a href="#val-div" class="anchor"></a><code><span><span class="keyword">val</span> div : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Float division. Care to guard for division by zero as it is not intrisectly guarranteed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-comp" class="anchored"><a href="#val-comp" class="anchor"></a><code><span><span class="keyword">val</span> comp : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Comparison operation. The operator is given as C-style string literal</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dfun" class="anchored"><a href="#val-dfun" class="anchor"></a><code><span><span class="keyword">val</span> dfun : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-constr">constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Function call</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dinstr" class="anchored"><a href="#val-dinstr" class="anchor"></a><code><span><span class="keyword">val</span> dinstr : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Direct instruction</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dlow_level" class="anchored"><a href="#val-dlow_level" class="anchor"></a><code><span><span class="keyword">val</span> dlow_level : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Direct instruction, not pushed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-access" class="anchored"><a href="#val-access" class="anchor"></a><code><span><span class="keyword">val</span> access : <span><a href="../Com/Var/index.html#type-t">Com.Var.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-dflag">dflag</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Arbitrary access to M TGV variable. Either defineness of valuation</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ite" class="anchored"><a href="#val-ite" class="anchor"></a><code><span><span class="keyword">val</span> ite : <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constr">constr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-constr">constr</a></span></code></div><div class="spec-doc"><p>Functionnal if-the-else construction. <code>ite cond_expr then_expr else_expr</code> is akin to <code>if cond_expr then then_expr else else_expr</code></p></div></div><h3 id="decoupled-expressions"><a href="#decoupled-expressions" class="anchor"></a>Decoupled expressions</h3><p>While <a href="#type-constr"><code>constr</code></a> is the expression language for decoupled values, the following represents complete and optimized expressions for M computations</p><div class="odoc-spec"><div class="spec type" id="type-expression_composition" class="anchored"><a href="#type-expression_composition" class="anchor"></a><code><span><span class="keyword">type</span> expression_composition</span><span> = </span><span>{</span></code><table><tr id="type-expression_composition.set_vars" class="anchored"><td class="def record field"><a href="#type-expression_composition.set_vars" class="anchor"></a><code><span>set_vars : <span><span>(<a href="#type-dflag">dflag</a> * string * <a href="#type-constr">constr</a>)</span> list</span>;</span></code></td></tr><tr id="type-expression_composition.def_test" class="anchored"><td class="def record field"><a href="#type-expression_composition.def_test" class="anchor"></a><code><span>def_test : <a href="#type-constr">constr</a>;</span></code></td></tr><tr id="type-expression_composition.value_comp" class="anchored"><td class="def record field"><a href="#type-expression_composition.value_comp" class="anchor"></a><code><span>value_comp : <a href="#type-constr">constr</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Representation of an M computation in construction. <code>def_test</code> for the defineness flag, and <code>value_comp</code> for the actual valuation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_transitive_composition" class="anchored"><a href="#val-build_transitive_composition" class="anchor"></a><code><span><span class="keyword">val</span> build_transitive_composition : 
  <span>?safe_def:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-expression_composition">expression_composition</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-expression_composition">expression_composition</a></span></code></div><div class="spec-doc"><p>Refine an expression composition to enfore M invariants. Mainly the fact that undefined value are valuated to zero. <code>value_comp</code> of the argument is expected to be defined assuming the expression <i>is</i> defined. <code>safe_def</code>, which defaults to <code>false</code>, can be set when the defined <code>value_comp</code> computation will evaluate to zero if <code>def_test</code> do, allowing the guard to be optimized away.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Decoupled expression type. Closed representation of a computation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_always_true" class="anchored"><a href="#val-is_always_true" class="anchor"></a><code><span><span class="keyword">val</span> is_always_true : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Tells if the expression <code>t</code> reprensents a value statically different to zero</p></div></div><div class="odoc-spec"><div class="spec type" id="type-local_decls" class="anchored"><a href="#type-local_decls" class="anchor"></a><code><span><span class="keyword">type</span> local_decls</span></code></div><div class="spec-doc"><p>Representation of local variables existing in an expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-build_expression" class="anchored"><a href="#val-build_expression" class="anchor"></a><code><span><span class="keyword">val</span> build_expression : 
  <span><a href="#type-expression_composition">expression_composition</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-local_decls">local_decls</a> * <span><span>(<a href="#type-dflag">dflag</a> * string * <a href="#type-t">t</a>)</span> list</span> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Crush <a href="#type-constr"><code>constr</code></a> values into closed expressions <a href="#type-t"><code>t</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-format_local_declarations" class="anchored"><a href="#val-format_local_declarations" class="anchor"></a><code><span><span class="keyword">val</span> format_local_declarations : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-local_decls">local_decls</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-format_assign" class="anchored"><a href="#val-format_assign" class="anchor"></a><code><span><span class="keyword">val</span> format_assign : 
  <span><a href="../Dgfip_options/index.html#type-flags">Dgfip_options.flags</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-format_set_vars" class="anchored"><a href="#val-format_set_vars" class="anchor"></a><code><span><span class="keyword">val</span> format_set_vars : 
  <span><a href="../Dgfip_options/index.html#type-flags">Dgfip_options.flags</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-dflag">dflag</a> * string * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div></div></body></html>