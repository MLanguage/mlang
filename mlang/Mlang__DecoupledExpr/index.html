<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mlang__DecoupledExpr (mlang.Mlang__DecoupledExpr)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">mlang</a> &#x00BB; Mlang__DecoupledExpr</nav><h1>Module <code>Mlang__DecoupledExpr</code></h1><nav class="toc"><ul><li><a href="#low-level-m-computation">Low-level M computation</a><ul><li><a href="#local-variables">Local variables</a></li><li><a href="#constr">Expression constructors</a></li><li><a href="#decoupled-expressions">Decoupled expressions</a></li></ul></li></ul></nav></header><dl><dt class="spec type" id="type-offset"><a href="#type-offset" class="anchor"></a><code><span class="keyword">type</span> offset</code><code> = </code><table class="variant"><tr id="type-offset.GetValueConst" class="anchored"><td class="def constructor"><a href="#type-offset.GetValueConst" class="anchor"></a><code>| </code><code><span class="constructor">GetValueConst</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-offset.GetValueVar" class="anchored"><td class="def constructor"><a href="#type-offset.GetValueVar" class="anchor"></a><code>| </code><code><span class="constructor">GetValueVar</span> <span class="keyword">of</span> <a href="../Mlang/Bir/index.html#type-variable">Mlang.Bir.variable</a></code></td></tr><tr id="type-offset.PassPointer" class="anchored"><td class="def constructor"><a href="#type-offset.PassPointer" class="anchor"></a><code>| </code><code><span class="constructor">PassPointer</span></code></td></tr><tr id="type-offset.None" class="anchored"><td class="def constructor"><a href="#type-offset.None" class="anchor"></a><code>| </code><code><span class="constructor">None</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-generate_variable"><a href="#val-generate_variable" class="anchor"></a><code><span class="keyword">val</span> generate_variable : <a href="../Mlang/Dgfip_varid/index.html#type-var_id_map">Mlang.Dgfip_varid.var_id_map</a> <span>&#45;&gt;</span> <a href="index.html#type-offset">offset</a> <span>&#45;&gt;</span> <span>?&#8288;def_flag:bool</span> <span>&#45;&gt;</span> <span>?&#8288;debug_flag:bool</span> <span>&#45;&gt;</span> <a href="../Mlang/Bir/index.html#type-variable">Mlang.Bir.variable</a> <span>&#45;&gt;</span> string</code></dt></dl><dl><dt class="spec type" id="type-dflag"><a href="#type-dflag" class="anchor"></a><code><span class="keyword">type</span> dflag</code><code> = </code><table class="variant"><tr id="type-dflag.Def" class="anchored"><td class="def constructor"><a href="#type-dflag.Def" class="anchor"></a><code>| </code><code><span class="constructor">Def</span></code></td></tr><tr id="type-dflag.Val" class="anchored"><td class="def constructor"><a href="#type-dflag.Val" class="anchor"></a><code>| </code><code><span class="constructor">Val</span></code></td></tr></table></dt></dl><section><header><h2 id="low-level-m-computation"><a href="#low-level-m-computation" class="anchor"></a>Low-level M computation</h2></header><aside><p>This module distinguish defineness and valuation computations of M expressions so they can be expressed independantly and more thoroughtly optimized. Definition of such expression follows as such:</p><ul><li>Express the computation of definess and valuation independantly through the use of constructors in <a href="index.html#constr"><span>Expression constructors</span></a></li><li>Sub-expressions can be used to build up the M expression tree (see <a href="index.html#type-expression_composition"><code>expression_composition</code></a>)</li><li>A fully defined expression can be processed into a optimized value that can be printed (<a href="index.html#val-build_expression"><code>build_expression</code></a>)</li></ul></aside><section><header><h3 id="local-variables"><a href="#local-variables" class="anchor"></a>Local variables</h3></header><dl><dt class="spec type" id="type-local_var"><a href="#type-local_var" class="anchor"></a><code><span class="keyword">type</span> local_var</code></dt><dd><p>Variable local to the computed expression</p></dd></dl><dl><dt class="spec value" id="val-locals_from_m"><a href="#val-locals_from_m" class="anchor"></a><code><span class="keyword">val</span> locals_from_m : <a href="../Mlang/Mir/LocalVariable/index.html#type-t">Mlang.Mir.LocalVariable.t</a> <span>&#45;&gt;</span> <a href="index.html#type-local_var">local_var</a> * <a href="index.html#type-local_var">local_var</a></code></dt><dd><p>Return a couple of local variable from a MIR one, for defineness and valuation in this order.</p></dd></dl><dl><dt class="spec value" id="val-new_local"><a href="#val-new_local" class="anchor"></a><code><span class="keyword">val</span> new_local : unit <span>&#45;&gt;</span> <a href="index.html#type-local_var">local_var</a></code></dt><dd><p>Create a fresh local variable</p></dd></dl></section><section><header><h3 id="constr"><a href="#constr" class="anchor"></a>Expression constructors</h3></header><aside><p>These are the smart constructors used to build expressions. In effect, they represent the language in which computations are defined.</p></aside><aside><p>They are used as traditional nestable sum-type constructors. An example:</p><pre>0.5 * (x + y)</pre><p>would turn into</p><pre><code class="ml">mult (lit 0.5) (plus (local_var x) (local_var y)) </code></pre><p>where <code>x</code> and <code>y</code> are previously defined <a href="index.html#type-local_var"><code>local_var</code></a>s</p></aside><dl><dt class="spec type" id="type-constr"><a href="#type-constr" class="anchor"></a><code><span class="keyword">type</span> constr</code></dt><dd><p>Constructed decoupled expression</p></dd></dl><dl><dt class="spec value" id="val-dtrue"><a href="#val-dtrue" class="anchor"></a><code><span class="keyword">val</span> dtrue : <a href="index.html#type-constr">constr</a></code></dt><dd><p>True value</p></dd></dl><dl><dt class="spec value" id="val-dfalse"><a href="#val-dfalse" class="anchor"></a><code><span class="keyword">val</span> dfalse : <a href="index.html#type-constr">constr</a></code></dt><dd><p>False value</p></dd></dl><dl><dt class="spec value" id="val-lit"><a href="#val-lit" class="anchor"></a><code><span class="keyword">val</span> lit : float <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Float literal</p></dd></dl><dl><dt class="spec value" id="val-m_var"><a href="#val-m_var" class="anchor"></a><code><span class="keyword">val</span> m_var : <a href="../Mlang/Bir/index.html#type-variable">Mlang.Bir.variable</a> <span>&#45;&gt;</span> <a href="index.html#type-offset">offset</a> <span>&#45;&gt;</span> <a href="index.html#type-dflag">dflag</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Value from TGV. <code>m_var v off df</code> represents an access to the TGV variable <code>v</code> with <code>df</code> to read defineness or valuation. <code>off</code> is the access type for M array, and should be <code>None</code> most of the time. For array access, see <a href="index.html#val-access"><code>access</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-let_local"><a href="#val-let_local" class="anchor"></a><code><span class="keyword">val</span> let_local : <a href="index.html#type-local_var">local_var</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Local let-binding. <code>let_local v defining_expr body_expr</code> is akin to OCaml <code>let v = defining_expr in body_expr</code></p></dd></dl><dl><dt class="spec value" id="val-local_var"><a href="#val-local_var" class="anchor"></a><code><span class="keyword">val</span> local_var : <a href="index.html#type-local_var">local_var</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Access local variable value</p></dd></dl><dl><dt class="spec value" id="val-dand"><a href="#val-dand" class="anchor"></a><code><span class="keyword">val</span> dand : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Boolean and</p></dd></dl><dl><dt class="spec value" id="val-dor"><a href="#val-dor" class="anchor"></a><code><span class="keyword">val</span> dor : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Boolean or</p></dd></dl><dl><dt class="spec value" id="val-dnot"><a href="#val-dnot" class="anchor"></a><code><span class="keyword">val</span> dnot : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Boolean not</p></dd></dl><dl><dt class="spec value" id="val-minus"><a href="#val-minus" class="anchor"></a><code><span class="keyword">val</span> minus : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Negate value</p></dd></dl><dl><dt class="spec value" id="val-plus"><a href="#val-plus" class="anchor"></a><code><span class="keyword">val</span> plus : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Float addition</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Float substraction</p></dd></dl><dl><dt class="spec value" id="val-mult"><a href="#val-mult" class="anchor"></a><code><span class="keyword">val</span> mult : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Float multiplication</p></dd></dl><dl><dt class="spec value" id="val-div"><a href="#val-div" class="anchor"></a><code><span class="keyword">val</span> div : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Float division. Care to guard for division by zero as it is not intrisectly guarranteed</p></dd></dl><dl><dt class="spec value" id="val-comp"><a href="#val-comp" class="anchor"></a><code><span class="keyword">val</span> comp : string <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Comparison operation. The operator is given as C-style string literal</p></dd></dl><dl><dt class="spec value" id="val-dfun"><a href="#val-dfun" class="anchor"></a><code><span class="keyword">val</span> dfun : string <span>&#45;&gt;</span> <span><a href="index.html#type-constr">constr</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Function call</p></dd></dl><dl><dt class="spec value" id="val-access"><a href="#val-access" class="anchor"></a><code><span class="keyword">val</span> access : <a href="../Mlang/Bir/index.html#type-variable">Mlang.Bir.variable</a> <span>&#45;&gt;</span> <a href="index.html#type-dflag">dflag</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Arbitrary access to M TGV variable. Either defineness of valuation</p></dd></dl><dl><dt class="spec value" id="val-ite"><a href="#val-ite" class="anchor"></a><code><span class="keyword">val</span> ite : <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a> <span>&#45;&gt;</span> <a href="index.html#type-constr">constr</a></code></dt><dd><p>Functionnal if-the-else construction. <code>ite cond_expr then_expr else_expr</code> is akin to <code>if cond_expr then then_expr else else_expr</code></p></dd></dl></section><section><header><h3 id="decoupled-expressions"><a href="#decoupled-expressions" class="anchor"></a>Decoupled expressions</h3></header><aside><p>While <a href="index.html#constr"><span>Expression constructors</span></a> is the expression language for decoupled values, the following represents complete and optimized expressions for M computations</p></aside><dl><dt class="spec type" id="type-expression_composition"><a href="#type-expression_composition" class="anchor"></a><code><span class="keyword">type</span> expression_composition</code><code> = </code><code>{</code><table class="record"><tr id="type-expression_composition.def_test" class="anchored"><td class="def field"><a href="#type-expression_composition.def_test" class="anchor"></a><code>def_test : <a href="index.html#type-constr">constr</a>;</code></td></tr><tr id="type-expression_composition.value_comp" class="anchored"><td class="def field"><a href="#type-expression_composition.value_comp" class="anchor"></a><code>value_comp : <a href="index.html#type-constr">constr</a>;</code></td></tr></table><code>}</code></dt><dd><p>Representation of an M computation in construction. <code>def_test</code> for the defineness flag, and <code>value_comp</code> for the actual valuation.</p></dd></dl><dl><dt class="spec value" id="val-build_transitive_composition"><a href="#val-build_transitive_composition" class="anchor"></a><code><span class="keyword">val</span> build_transitive_composition : <span>?&#8288;safe_def:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-expression_composition">expression_composition</a> <span>&#45;&gt;</span> <a href="index.html#type-expression_composition">expression_composition</a></code></dt><dd><p>Refine an expression composition to enfore M invariants. Mainly the fact that undefined value are valuated to zero. <code>value_comp</code> of the argument is expected to be defined assuming the expression <i>is</i> defined. <code>safe_def</code>, which defaults to <code>false</code>, can be set when the defined <code>value_comp</code> computation will evaluate to zero if <code>def_test</code> do, allowing the guard to be optimized away.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Decoupled expression type. Closed representation of a computation.</p></dd></dl><dl><dt class="spec value" id="val-is_always_true"><a href="#val-is_always_true" class="anchor"></a><code><span class="keyword">val</span> is_always_true : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Tells if the expression <code>t</code> reprensents a value statically different to zero</p></dd></dl><dl><dt class="spec type" id="type-local_decls"><a href="#type-local_decls" class="anchor"></a><code><span class="keyword">type</span> local_decls</code></dt><dd><p>Representation of local variables existing in an expression</p></dd></dl><dl><dt class="spec value" id="val-build_expression"><a href="#val-build_expression" class="anchor"></a><code><span class="keyword">val</span> build_expression : <a href="index.html#type-expression_composition">expression_composition</a> <span>&#45;&gt;</span> <a href="index.html#type-local_decls">local_decls</a> * <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>Crush <a href="index.html#constr"><span>Expression constructors</span></a> values into closed expressions <a href="index.html#type-t"><code>t</code></a></p></dd></dl><dl><dt class="spec value" id="val-format_local_declarations"><a href="#val-format_local_declarations" class="anchor"></a><code><span class="keyword">val</span> format_local_declarations : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-local_decls">local_decls</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-format_assign"><a href="#val-format_assign" class="anchor"></a><code><span class="keyword">val</span> format_assign : <a href="../Mlang/Dgfip_options/index.html#type-flags">Mlang.Dgfip_options.flags</a> <span>&#45;&gt;</span> <a href="../Mlang/Dgfip_varid/index.html#type-var_id_map">Mlang.Dgfip_varid.var_id_map</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></section></section></div></body></html>