<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (mlang.index)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ mlang</nav><header class="odoc-preamble"><h1 id="mlang"><a href="#mlang" class="anchor"></a>Mlang</h1><p>The Mlang compiler has a traditionnal architecture consisting of various intermediate representations going from the source code to the target backend.</p></header><nav class="odoc-toc"><ul><li><a href="#m-frontend">M Frontend</a></li><li><a href="#m-intermediate-representation">M Intermediate representation</a></li><li><a href="#m++-frontend">M++ Frontend</a></li><li><a href="#m++-intermediate-representation">M++ Intermediate representation</a></li><li><a href="#m/m++-common-backend-intermediate-representation">M/M++ Common backend intermediate representation</a></li><li><a href="#optimizations">Optimizations</a></li><li><a href="#testing-m-and-m++-programs">Testing M and M++ programs</a></li><li><a href="#compiling-m-and-m++-programs">Compiling M and M++ programs</a></li><li><a href="#utils">Utils</a></li></ul></nav><div class="odoc-content"><h2 id="m-frontend"><a href="#m-frontend" class="anchor"></a>M Frontend</h2><p>First, the source code is parsed according to the Menhir grammar specified in <a href="Mlang/Mparser/index.html"><code>Mlang.Mparser</code></a>. The grammar is not exactly LR(1) so we rely on <a href="Mlang/Parse_utils/index.html"><code>Mlang.Parse_utils</code></a> to backtrack, especially on symbol parsing. The target intermediate representation is <a href="Mlang/Mast/index.html"><code>Mlang.Mast</code></a>, which is very close to the concrete syntax and can be printed using <a href="Mlang/Format_mast/index.html"><code>Mlang.Format_mast</code></a>.</p><ul class="modules"><li><a href="Mlang/Mast/index.html"><code>Mlang.Mast</code></a> <span class="synopsis">Abstract Syntax Tree for M</span></li><li><a href="Mlang/Format_mast/index.html"><code>Mlang.Format_mast</code></a> </li><li><a href="Mlang/Mparser/index.html"><code>Mlang.Mparser</code></a> </li><li><a href="Mlang/Parse_utils/index.html"><code>Mlang.Parse_utils</code></a> <span class="synopsis">Helpers for parsing</span></li></ul><h2 id="m-intermediate-representation"><a href="#m-intermediate-representation" class="anchor"></a>M Intermediate representation</h2><p>The M language has a lot of weird syntactic sugars and constructs linked to its usage inside multiple DGFiP applications. <a href="Mlang/Mast_to_mir/index.html"><code>Mlang.Mast_to_mir</code></a> extracts from the AST the computational core corresponding to a DGFiP application into the M Variable Graph (<a href="Mlang/Mir/index.html"><code>Mlang.Mir</code></a>), which consists basically of a flat map of all the definitions of the variables used in the application. The type system of M is very primitive, and basically all programs typecheck ; however <code>Mlang</code>.Mir_typechecker provides a top-down typechecking algorithm to split simple variables from tables.</p><p>At this point, the <code>Mlang</code>.Mir_dependency_graph modules interprets the MIR as a first-class graph and computes various reachability and cycle analysis in order to determine the computational flow inside the program. This dependency order is encapsulated with the program in <code>Mlang</code>.Mir_interface. Some typechecking and macro expansion is performed by <code>Mlang</code>.Mir_typechecker.</p><ul class="modules"><li><a href="Mlang/Mir/index.html"><code>Mlang.Mir</code></a> </li><li><a href="Mlang/Mast_to_mir/index.html"><code>Mlang.Mast_to_mir</code></a> <span class="synopsis"><code>Mast</code> to <code>Mir</code> translation of M programs.</span></li><li><a href="Mlang/Format_mir/index.html"><code>Mlang.Format_mir</code></a> </li><li><code>Mlang</code>.Mir_typechecker </li><li><code>Mlang</code>.Mir_interface </li><li><code>Mlang</code>.Mir_dependency_graph </li></ul><h2 id="m++-frontend"><a href="#m++-frontend" class="anchor"></a>M++ Frontend</h2><p>The M code can be called several times through a sort of driver that saves some variables between calls. This driver is encoded in the M++ domain-specific language that Mlang handles together with the M. M++ is parsed with <code>Mlang</code>.Mpp_parser</p><ul class="modules"><li><code>Mlang</code>.Mpp_parser </li><li><code>Mlang</code>.Mpp_ast </li></ul><h2 id="m++-intermediate-representation"><a href="#m++-intermediate-representation" class="anchor"></a>M++ Intermediate representation</h2><p>From the M++ AST, <code>Mlang</code>.Mpp_frontend translates to <code>Mlang</code>.Mpp_ir by eliminating some syntactic sugars.</p><ul class="modules"><li><code>Mlang</code>.Mpp_frontend </li><li><code>Mlang</code>.Mpp_ir </li><li><code>Mlang</code>.Mpp_format </li></ul><h2 id="m/m++-common-backend-intermediate-representation"><a href="#m/m++-common-backend-intermediate-representation" class="anchor"></a>M/M++ Common backend intermediate representation</h2><p>The module <code>Mlang</code>.Mpp_ir_to_bir performs the inlining of all the M calls in the M++ programs and yields a single program in a new common intermediate representation, <code>Mlang</code>.Bir. Inputs and outputs for this representation can be specified using <code>Mlang</code>.Bir_interface.</p><p>The BIR representation is equipped with a fully fledged interpreter, <code>Mlang</code>.Bir_interpreter. The interpreter is instrumented for code coverage via <code>Mlang</code>.Bir_instrumentation, and can be parametrized via multiple sorts of custom floating point values for precision testing (<code>Mlang</code>.Bir_number).</p><ul class="modules"><li><code>Mlang</code>.Bir_instrumentation </li><li><code>Mlang</code>.Bir_interface </li><li><code>Mlang</code>.Bir_interpreter </li><li><code>Mlang</code>.Bir_number </li><li><code>Mlang</code>.Bir </li><li><code>Mlang</code>.Format_bir </li></ul><h2 id="optimizations"><a href="#optimizations" class="anchor"></a>Optimizations</h2><p>While BIR is an AST-based representation, <code>Mlang</code>.Oir defines a dual of BIR in a control-flow-graph (CFG) for. You can go back and forth between those two implementations using <code>Mpp</code>.Bir_to_oir.</p><p>OIR is the right place to perform some basic program optimizations. <code>Mlang</code>.Inlining expands some of the small rules into their full expressions, while <code>Mlang</code>.Partial_evaluation and <code>Mlang</code>.Dead_code_removal simplify the program depending on the inputs and outputs. The main optimizing loop is implemented in <code>Mlang</code>.Oir_optimizations.</p><ul class="modules"><li><code>Mlang</code>.Oir_optimizations </li><li><code>Mlang</code>.Inlining </li><li><code>Mlang</code>.Partial_evaluation </li><li><code>Mlang</code>.Dead_code_removal </li></ul><h2 id="testing-m-and-m++-programs"><a href="#testing-m-and-m++-programs" class="anchor"></a>Testing M and M++ programs</h2><p>Mlang comes with a testing framework for M and M++ programs that is based on the test format used by the DGFiP. The test files are parsed with <code>Mlang</code>.Test_parser into <code>Mlang</code>.Test_ast. Then, single or batch testing can be performed using <a href="Mlang/Test_interpreter/index.html"><code>Mlang.Test_interpreter</code></a>.</p><ul class="modules"><li><code>Mlang</code>.Test_ast </li><li><a href="Mlang/Test_interpreter/index.html"><code>Mlang.Test_interpreter</code></a> </li><li><code>Mlang</code>.Test_parser </li></ul><h2 id="compiling-m-and-m++-programs"><a href="#compiling-m-and-m++-programs" class="anchor"></a>Compiling M and M++ programs</h2><p>M/M++ programs can be compiled to other programming languages using several backends that take BIR and produce source code files in their respective languages.</p><ul class="modules"><li><code>Mlang</code>.Bir_to_python </li><li><code>Mlang</code>.Bir_to_c </li><li><a href="Mlang/Bir_to_dgfip_c/index.html"><code>Mlang.Bir_to_dgfip_c</code></a> <span class="synopsis">This module with a single entry point generates C files from a <code>Bir</code>.program.</span></li></ul><h2 id="utils"><a href="#utils" class="anchor"></a>Utils</h2><ul class="modules"><li><a href="Mlang/Cli/index.html"><code>Mlang.Cli</code></a> <span class="synopsis">Command-line interface helpers</span></li><li><a href="Mlang/Errors/index.html"><code>Mlang.Errors</code></a> </li><li><a href="Mlang/Pos/index.html"><code>Mlang.Pos</code></a> <span class="synopsis">A position in the source code is a file, as well as begin and end location of the form col:line</span></li></ul></div></body></html>